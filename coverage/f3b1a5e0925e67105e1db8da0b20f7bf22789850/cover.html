
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM/ibmcloud-volume-interface/config/config.go (96.3%)</option>
				
				<option value="file1">github.com/IBM/ibmcloud-volume-interface/config/tls.go (100.0%)</option>
				
				<option value="file2">github.com/IBM/ibmcloud-volume-interface/lib/utils/data_utils.go (100.0%)</option>
				
				<option value="file3">github.com/IBM/ibmcloud-volume-interface/lib/utils/error_types.go (75.0%)</option>
				
				<option value="file4">github.com/IBM/ibmcloud-volume-interface/lib/utils/error_utils.go (70.6%)</option>
				
				<option value="file5">github.com/IBM/ibmcloud-volume-interface/lib/utils/messages.go (100.0%)</option>
				
				<option value="file6">github.com/IBM/ibmcloud-volume-interface/lib/utils/time_tracker.go (100.0%)</option>
				
				<option value="file7">github.com/IBM/ibmcloud-volume-interface/provider/auth/apikey.go (100.0%)</option>
				
				<option value="file8">github.com/IBM/ibmcloud-volume-interface/provider/auth/factory.go (80.0%)</option>
				
				<option value="file9">github.com/IBM/ibmcloud-volume-interface/provider/auth/ims_token.go (0.0%)</option>
				
				<option value="file10">github.com/IBM/ibmcloud-volume-interface/provider/iam/token_exchange.go (97.3%)</option>
				
				<option value="file11">github.com/IBM/ibmcloud-volume-interface/provider/iam/token_validation.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package config ...
package config

import (
        "os"
        "path/filepath"
        "strings"

        "github.com/BurntSushi/toml"
        "github.com/kelseyhightower/envconfig"
        "go.uber.org/zap"
)

func getEnv(key string) string <span class="cov10" title="12">{
        return os.Getenv(strings.ToUpper(key))
}</span>

// GetGoPath inspects the environment for the GOPATH variable
func GetGoPath() string <span class="cov8" title="7">{
        if goPath := getEnv("GOPATH"); goPath != "" </span><span class="cov3" title="2">{
                return goPath
        }</span>
        <span class="cov6" title="5">return ""</span>
}

// Config is the parent struct for all the configuration information for -cluster
type Config struct {
        Server    *ServerConfig  `required:"true"`
        Bluemix   *BluemixConfig //`required:"true"`
        Softlayer *SoftlayerConfig
        VPC       *VPCProviderConfig
        IKS       *IKSConfig
        API       *APIConfig
}

//ReadConfig loads the config from file
func ReadConfig(confPath string, logger *zap.Logger) (*Config, error) <span class="cov3" title="2">{
        // load the default config, if confPath not provided
        if confPath == "" </span><span class="cov1" title="1">{
                confPath = GetDefaultConfPath()
        }</span>

        // Parse config file
        <span class="cov3" title="2">conf := Config{
                IKS: &amp;IKSConfig{}, // IKS block may not be populated in secrete toml. Make sure its not nil
        }
        logger.Info("parsing conf file", zap.String("confpath", confPath))
        err := ParseConfig(confPath, &amp;conf, logger)
        return &amp;conf, err</span>
}

// GetConfPath get configuration file path
func GetConfPath() string <span class="cov3" title="2">{
        if confPath := getEnv("SECRET_CONFIG_PATH"); confPath != "" </span><span class="cov1" title="1">{
                return filepath.Join(confPath, "libconfig.toml")
        }</span>
        //Get default conf path
        <span class="cov1" title="1">return GetDefaultConfPath()</span>
}

// GetConfPathDir get configuration  dir path
func GetConfPathDir() string <span class="cov3" title="2">{
        if confPath := getEnv("SECRET_CONFIG_PATH"); confPath != "" </span><span class="cov1" title="1">{
                return confPath
        }</span>
        //Get default conf path
        <span class="cov1" title="1">return GetEtcPath()</span>
}

// GetDefaultConfPath get default config file path
func GetDefaultConfPath() string <span class="cov4" title="3">{
        return filepath.Join(GetEtcPath(), "libconfig.toml")
}</span>

// ParseConfig ...
func ParseConfig(filePath string, conf interface{}, logger *zap.Logger) error <span class="cov6" title="5">{
        _, err := toml.DecodeFile(filePath, conf)
        if err != nil </span><span class="cov1" title="1">{
                logger.Error("Failed to parse config file", zap.Error(err))
        }</span>
        // Read environment variables
        <span class="cov6" title="5">err = envconfig.Process("", conf)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to gather environment config variable", zap.Error(err))
        }</span>
        <span class="cov6" title="5">return err</span>
}

// ServerConfig configuration options for the provider server itself
type ServerConfig struct {
        // DebugTrace is a flag to enable the debug level trace within the provider code.
        DebugTrace bool `toml:"debug_trace" envconfig:"DEBUG_TRACE"`
}

// BluemixConfig ...
type BluemixConfig struct {
        IamURL          string `toml:"iam_url"`
        IamClientID     string `toml:"iam_client_id"`
        IamClientSecret string `toml:"iam_client_secret" json:"-"`
        IamAPIKey       string `toml:"iam_api_key" json:"-"`
        RefreshToken    string `toml:"refresh_token" json:"-"`
        APIEndpointURL  string `toml:"containers_api_route"`
        PrivateAPIRoute string `toml:"containers_api_route_private"`
        Encryption      bool   `toml:"encryption"`
        CSRFToken       string `toml:"containers_api_csrf_token" json:"-"`
}

// SoftlayerConfig ...
type SoftlayerConfig struct {
        SoftlayerBlockEnabled        bool   `toml:"softlayer_block_enabled" envconfig:"SOFTLAYER_BLOCK_ENABLED"`
        SoftlayerBlockProviderName   string `toml:"softlayer_block_provider_name" envconfig:"SOFTLAYER_BLOCK_PROVIDER_NAME"`
        SoftlayerFileEnabled         bool   `toml:"softlayer_file_enabled" envconfig:"SOFTLAYER_FILE_ENABLED"`
        SoftlayerFileProviderName    string `toml:"softlayer_file_provider_name" envconfig:"SOFTLAYER_FILE_PROVIDER_NAME"`
        SoftlayerUsername            string `toml:"softlayer_username" json:"-"`
        SoftlayerAPIKey              string `toml:"softlayer_api_key" json:"-"`
        SoftlayerEndpointURL         string `toml:"softlayer_endpoint_url"`
        SoftlayerDataCenter          string `toml:"softlayer_datacenter"`
        SoftlayerTimeout             string `toml:"softlayer_api_timeout" envconfig:"SOFTLAYER_API_TIMEOUT"`
        SoftlayerVolProvisionTimeout string `toml:"softlayer_vol_provision_timeout" envconfig:"SOFTLAYER_VOL_PROVISION_TIMEOUT"`
        SoftlayerRetryInterval       string `toml:"softlayer_api_retry_interval" envconfig:"SOFTLAYER_API_RETRY_INTERVAL"`

        //Configuration values for JWT tokens
        SoftlayerJWTKID       string `toml:"softlayer_jwt_kid"`
        SoftlayerJWTTTL       int    `toml:"softlayer_jwt_ttl"`
        SoftlayerJWTValidFrom int    `toml:"softlayer_jwt_valid"`

        SoftlayerIMSEndpointURL string `toml:"softlayer_iam_endpoint_url"`
        SoftlayerAPIDebug       bool
}

// VPCProviderConfig configures a specific instance of a VPC provider (e.g. GT/GC/Z)
type VPCProviderConfig struct {
        Enabled bool `toml:"vpc_enabled" envconfig:"VPC_ENABLED"`

        IamClientID     string `toml:"iam_client_id"`
        IamClientSecret string `toml:"iam_client_secret" json:"-"`

        //valid values (gc|g2), if unspecified, GC will take precedence(if both are specified)
        //during e2e test, user can specify its own preferred type during execution
        VPCTypeEnabled       string `toml:"vpc_type_enabled" envconfig:"VPC_TYPE_ENABLED"`
        VPCBlockProviderName string `toml:"vpc_block_provider_name" envconfig:"VPC_BLOCK_PROVIDER_NAME"`
        VPCBlockProviderType string `toml:"provider_type"`

        EndpointURL        string `toml:"gc_riaas_endpoint_url"`
        PrivateEndpointURL string `toml:"gc_riaas_endpoint_private_url"`
        TokenExchangeURL   string `toml:"gc_token_exchange_endpoint_url"`
        APIKey             string `toml:"gc_api_key" json:"-"`
        ResourceGroupID    string `toml:"gc_resource_group_id"`
        VPCAPIGeneration   int    `toml:"vpc_api_generation" envconfig:"VPC_API_GENERATION"`
        APIVersion         string `toml:"api_version,omitempty" envconfig:"VPC_API_VERSION"`

        //NG Properties
        G2EndpointURL        string `toml:"g2_riaas_endpoint_url"`
        G2EndpointPrivateURL string `toml:"g2_riaas_endpoint_private_url"`
        G2TokenExchangeURL   string `toml:"g2_token_exchange_endpoint_url"`
        G2APIKey             string `toml:"g2_api_key" json:"-"`
        G2ResourceGroupID    string `toml:"g2_resource_group_id"`
        G2VPCAPIGeneration   int    `toml:"g2_vpc_api_generation" envconfig:"G2_VPC_API_GENERATION"`
        G2APIVersion         string `toml:"g2_api_version,omitempty" envconfig:"G2_VPC_API_VERSION"`

        Encryption      bool   `toml:"encryption"`
        VPCTimeout      string `toml:"vpc_api_timeout,omitempty" envconfig:"VPC_API_TIMEOUT"`
        MaxRetryAttempt int    `toml:"max_retry_attempt,omitempty" envconfig:"VPC_RETRY_ATTEMPT"`
        MaxRetryGap     int    `toml:"max_retry_gap,omitempty" envconfig:"VPC_RETRY_INTERVAL"`
        // IKSTokenExchangePrivateURL, for private cluster support hence using for all cluster types
        IKSTokenExchangePrivateURL string `toml:"iks_token_exchange_endpoint_private_url"`

        IsIKS bool `toml:"is_iks,omitempty"`
}

//IKSConfig config
type IKSConfig struct {
        Enabled              bool   `toml:"iks_enabled" envconfig:"IKS_ENABLED"`
        IKSBlockProviderName string `toml:"iks_block_provider_name" envconfig:"IKS_BLOCK_PROVIDER_NAME"`
}

// APIConfig config
type APIConfig struct {
        PassthroughSecret string `toml:"PassthroughSecret" json:"-"`
}

// GetEtcPath returns the path to the etc directory
func GetEtcPath() string <span class="cov6" title="5">{
        goPath := GetGoPath()
        srcPath := filepath.Join("src", "github.com", "IBM",
                "ibmcloud-volume-interface")
        return filepath.Join(goPath, srcPath, "etc")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package config ...
package config

import (
        "crypto/tls"
        "net/http"
        "time"
)

// GeneralCAHttpClient returns an http.Client configured for general use
func GeneralCAHttpClient() (*http.Client, error) <span class="cov8" title="1">{
        httpClient := &amp;http.Client{

                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                MinVersion: tls.VersionTLS12, // Require TLS 1.2 or higher
                        },
                },

                // softlayer.go has been overriding http.DefaultClient and forcing 120s
                // timeout on us, so we'll continue to force it on ourselves in case
                // we've accidentally become acustomed to it.
                Timeout: time.Second * 120,
        }

        return httpClient, nil
}</span>

// GeneralCAHttpClientWithTimeout returns an http.Client configured for general use
func GeneralCAHttpClientWithTimeout(timeout time.Duration) (*http.Client, error) <span class="cov8" title="1">{
        httpClient := &amp;http.Client{

                Transport: &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                MinVersion: tls.VersionTLS12, // Require TLS 1.2 or higher
                        },
                },

                Timeout: timeout,
        }

        return httpClient, nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package util ...
package util

// SafeStringValue returns the referenced string value, treating nil as equivalent to "".
// It is intended as a type-safe and nil-safe test for empty values in data fields of
func SafeStringValue(s *string) string <span class="cov10" title="2">{
        if s == nil </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov1" title="1">return *s</span>
}

// StringHasValue returns true if the argument is neither nil nor a pointer to the
// zero/empty string.
func StringHasValue(s *string) bool <span class="cov1" title="1">{
        return s != nil &amp;&amp; *s != ""
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package util ...
package util

// These are the error types which all provider should categorize their errors
const (

        // ProvisioningFailed volume or snapshot provisioning failed
        ProvisioningFailed = "ProvisioningFailed"

        // DeletionFailed ...
        DeletionFailed = "DeletionFailed"

        // UpdateFailed ...
        UpdateFailed = "UpdateFailed"

        // RetrivalFailed ...
        RetrivalFailed = "RetrivalFailed"

        // InvalidRequest ...
        InvalidRequest = "InvalidRequest"

        // EntityNotFound ...
        EntityNotFound = "EntityNotFound"

        // PermissionDenied ...
        PermissionDenied = "PermissionDenied"

        // Unauthenticated ...
        Unauthenticated = "Unauthenticated"

        // ErrorTypeFailed ...
        ErrorTypeFailed = "ErrorTypeConversionFailed"

        // VolumeAttachFindFailed ...
        VolumeAttachFindFailed = "VolumeAttachFindFailed"

        // AttachFailed ...
        AttachFailed = "AttachFailed"

        // InstanceNotFound ...
        NodeNotFound = "NodeNotFound"

        // DetachFailed ...
        DetachFailed = "DetachFailed"

        // ExpansionFailed ...
        ExpansionFailed = "ExpansionFailed"
)

// GetErrorType return the user error type provided by volume provider
func GetErrorType(err error) string <span class="cov10" title="3">{
        providerError, ok := err.(Message)
        if ok </span><span class="cov0" title="0">{
                return providerError.Type
        }</span>
        <span class="cov10" title="3">return ErrorTypeFailed</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package util ...
package util

import (
        "errors"
        "reflect"
        "time"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
        "github.com/IBM/ibmcloud-volume-interface/lib/utils/reasoncode"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// NewError returns an error that is implemented by provider.Error.
// If optional wrapped errors are a provider.Error, this preserves all child wrapped
// errors in depth-first order.
func NewError(code reasoncode.ReasonCode, msg string, wrapped ...error) error <span class="cov8" title="18">{
        return NewErrorWithProperties(code, msg, nil, wrapped...)
}</span>

// NewErrorWithProperties returns an error that is implemented provider.Error and
// which is decorated with diagnostic properties.
// If optional wrapped errors are a provider.Error, this preserves all child wrapped
// errors in depth-first order.
func NewErrorWithProperties(code reasoncode.ReasonCode, msg string, properties map[string]string, wrapped ...error) error <span class="cov9" title="23">{
        if code == "" </span><span class="cov2" title="2">{
                code = "" // TODO: ErrorUnclassified
        }</span>
        <span class="cov9" title="23">var werrs []string
        for _, w := range wrapped </span><span class="cov10" title="29">{
                if w != nil </span><span class="cov9" title="23">{
                        werrs = append(werrs, w.Error())
                        if p, isPerr := w.(provider.Error); isPerr </span><span class="cov4" title="4">{
                                werrs = append(werrs, p.Wrapped()...)
                        }</span>
                }
        }
        <span class="cov9" title="23">return provider.Error{
                Fault: provider.Fault{
                        ReasonCode: code,
                        Message:    msg,
                        Properties: properties,
                        Wrapped:    werrs,
                },
        }</span>
}

// ErrorDeepUnwrapString returns the full list of unwrapped error strings
// Returns empty slice if not a provider.Error
func ErrorDeepUnwrapString(err error) []string <span class="cov5" title="6">{
        if perr, isPerr := err.(provider.Error); isPerr &amp;&amp; perr.Wrapped() != nil </span><span class="cov3" title="3">{
                return perr.Wrapped()
        }</span>
        <span class="cov3" title="3">return []string{}</span>
}

// ErrorReasonCode returns reason code if a provider.Error, else ErrorUnclassified
func ErrorReasonCode(err error) reasoncode.ReasonCode <span class="cov2" title="2">{
        if pErr, isPerr := err.(provider.Error); isPerr </span><span class="cov1" title="1">{
                if code := pErr.Code(); code != "" </span><span class="cov1" title="1">{
                        return code
                }</span>
        }
        <span class="cov1" title="1">return reasoncode.ErrorUnclassified</span>
}

// ErrorToFault returns or builds a Fault pointer for an error (e.g. for a response object)
// Returns nil if no error,
func ErrorToFault(err error) *provider.Fault <span class="cov4" title="4">{
        if err == nil </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov2" title="2">if pErr, isPerr := err.(provider.Error); isPerr </span><span class="cov1" title="1">{
                return &amp;pErr.Fault
        }</span>
        <span class="cov1" title="1">return &amp;provider.Fault{
                ReasonCode: "", // TODO: ErrorUnclassified,
                Message:    err.Error(),
        }</span>
}

// FaultToError builds a Error from a Fault pointer (e.g. from a response object)
// Returns nil error if no Fault.
func FaultToError(fault *provider.Fault) error <span class="cov2" title="2">{
        if fault == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov1" title="1">return provider.Error{Fault: *fault}</span>
}

// SetFaultResponse sets the Fault field of any response struct
func SetFaultResponse(fault error, response interface{}) error <span class="cov4" title="4">{
        value := reflect.ValueOf(response)
        if value.Kind() != reflect.Ptr || value.Elem().Kind() != reflect.Struct </span><span class="cov1" title="1">{
                return errors.New("value must be a pointer to a struct")
        }</span>
        <span class="cov3" title="3">field := value.Elem().FieldByName("Fault")
        if field.Kind() != reflect.Ptr </span><span class="cov2" title="2">{
                return errors.New("value struct must have Fault provider.Fault field")
        }</span>
        <span class="cov1" title="1">field.Set(reflect.ValueOf(ErrorToFault(fault)))
        return nil</span>
}

// ZapError returns a zapcore.Field for an error that includes the metadata
// associated with a provider.Error. If the error is not a provider.Error then
// the standard zap.Error is used.
func ZapError(err error) zapcore.Field <span class="cov3" title="3">{
        if perr, isPerr := err.(provider.Error); isPerr </span><span class="cov1" title="1">{
                // Use zap.Relfect() to format all fields of struct
                // zap.Any() would select standard error formatting
                return zap.Reflect("error", perr)
        }</span>

        <span class="cov2" title="2">return zap.Error(err)</span>
}

//ErrorRetrier retry the function
type ErrorRetrier struct {
        MaxAttempts   int
        RetryInterval time.Duration
        Logger        *zap.Logger
}

//NewErrorRetrier return new ErrorRetrier
func NewErrorRetrier(maxAttempt int, retryInterval time.Duration, logger *zap.Logger) *ErrorRetrier <span class="cov0" title="0">{
        return &amp;ErrorRetrier{
                MaxAttempts:   maxAttempt,
                RetryInterval: retryInterval,
                Logger:        logger,
        }
}</span>

//ErrorRetry path for retry logic with logger passed in
func (er *ErrorRetrier) ErrorRetry(funcToRetry func() (error, bool)) error <span class="cov0" title="0">{
        var err error
        var shouldStop bool
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                err, shouldStop = funcToRetry()
                er.Logger.Debug("Retry Function Result", zap.Error(err), zap.Bool("shouldStop", shouldStop))
                if shouldStop </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                //Stop if out of retries
                <span class="cov0" title="0">if i &gt;= (er.MaxAttempts - 1) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">time.Sleep(er.RetryInterval)
                er.Logger.Warn("retrying after Error:", zap.Error(err))</span>
        }
        //error set by name above so no need to explicitly return it
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package util ...
package util

import (
        "fmt"
)

// Message Wrapper Message/Error Class
type Message struct {
        Code         string
        Type         string
        RequestID    string
        Description  string
        BackendError string
        RC           int
        Action       string
}

// Error Implement the Error() interface method
func (msg Message) Error() string <span class="cov10" title="2">{
        return msg.Info()
}</span>

// Info ...
func (msg Message) Info() string <span class="cov10" title="2">{
        return fmt.Sprintf("{Code:%s, Type:%s, Description:%s, BackendError:%s, RC:%d}", msg.Code, msg.Type, msg.Description, msg.BackendError, msg.RC)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package util ...
package util

import (
        "fmt"
        "log"
        "time"
)

// TimeTracker Get execution time of a function
func TimeTracker(functionName string, start time.Time) <span class="cov8" title="1">{
        elapsed := time.Since(start)

        log.Println(fmt.Sprintf("TIME TAKEN BY FUNCTION %s IS %s", functionName, elapsed))
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package auth ...
package auth

import (
        "go.uber.org/zap"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
)

// ForIaaSAPIKey ...
func (ccf *ContextCredentialsFactory) ForIaaSAPIKey(iamAccountID, userid, apikey string, logger *zap.Logger) (provider.ContextCredentials, error) <span class="cov8" title="1">{
        return provider.ContextCredentials{
                AuthType:     provider.IaaSAPIKey,
                IAMAccountID: iamAccountID,
                UserID:       userid,
                Credential:   apikey,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package auth ...
package auth

import (
        "github.com/IBM/ibmcloud-volume-interface/provider/iam"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"
)

// ContextCredentialsFactory ...
type ContextCredentialsFactory struct {
        TokenExchangeService iam.TokenExchangeService
}

var _ local.ContextCredentialsFactory = &amp;ContextCredentialsFactory{}

// NewContextCredentialsFactory ...
func NewContextCredentialsFactory(authConfig *iam.AuthConfiguration) (*ContextCredentialsFactory, error) <span class="cov8" title="1">{
        var tokenExchangeService iam.TokenExchangeService

        tokenExchangeService, err := iam.NewTokenExchangeService(authConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;ContextCredentialsFactory{
                TokenExchangeService: tokenExchangeService,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package auth ...
package auth

import (
        "strconv"

        "go.uber.org/zap"

        "github.com/IBM/ibmcloud-volume-interface/provider/iam"
        "github.com/IBM/ibmcloud-volume-interface/provider/local"

        "github.com/IBM/ibmcloud-volume-interface/lib/provider"
)

const (
        // IMSToken is an IMS user ID and token
        IMSToken = provider.AuthType("IMS_TOKEN")
        // IAMAccessToken ...
        IAMAccessToken = provider.AuthType("IAM_ACCESS_TOKEN")
)

// ForRefreshToken ...
func (ccf *ContextCredentialsFactory) ForRefreshToken(refreshToken string, logger *zap.Logger) (provider.ContextCredentials, error) <span class="cov0" title="0">{
        accessToken, err := ccf.TokenExchangeService.ExchangeRefreshTokenForAccessToken(refreshToken, logger)
        if err != nil </span><span class="cov0" title="0">{
                // Must preserve provider error code in the ErrorProviderAccountTemporarilyLocked case
                logger.Error("Unable to retrieve access token from refresh token", local.ZapError(err))
                return provider.ContextCredentials{}, err
        }</span>

        <span class="cov0" title="0">imsToken, err := ccf.TokenExchangeService.ExchangeAccessTokenForIMSToken(*accessToken, logger)
        if err != nil </span><span class="cov0" title="0">{
                // Must preserve provider error code in the ErrorProviderAccountTemporarilyLocked case
                logger.Error("Unable to retrieve IAM token from access token", local.ZapError(err))
                return provider.ContextCredentials{}, err
        }</span>

        <span class="cov0" title="0">return forIMSToken("", imsToken), nil</span>
}

// ForIAMAPIKey ...
func (ccf *ContextCredentialsFactory) ForIAMAPIKey(iamAccountID, apiKey string, logger *zap.Logger) (provider.ContextCredentials, error) <span class="cov0" title="0">{
        imsToken, err := ccf.TokenExchangeService.ExchangeIAMAPIKeyForIMSToken(apiKey, logger)
        if err != nil </span><span class="cov0" title="0">{
                // Must preserve provider error code in the ErrorProviderAccountTemporarilyLocked case
                logger.Error("Unable to retrieve IMS credentials from IAM API key", local.ZapError(err))
                return provider.ContextCredentials{}, err
        }</span>

        <span class="cov0" title="0">return forIMSToken(iamAccountID, imsToken), nil</span>
}

// ForIAMAccessToken ...
func (ccf *ContextCredentialsFactory) ForIAMAccessToken(apiKey string, logger *zap.Logger) (provider.ContextCredentials, error) <span class="cov0" title="0">{
        iamAccessToken, err := ccf.TokenExchangeService.ExchangeIAMAPIKeyForAccessToken(apiKey, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Unable to retrieve IAM access token from IAM API key", local.ZapError(err))
                return provider.ContextCredentials{}, err
        }</span>
        <span class="cov0" title="0">iamAccountID, err := ccf.TokenExchangeService.GetIAMAccountIDFromAccessToken(iam.AccessToken{Token: iamAccessToken.Token}, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Unable to retrieve IAM access token from IAM API key", local.ZapError(err))
                return provider.ContextCredentials{}, err
        }</span>

        <span class="cov0" title="0">return forIAMAccessToken(iamAccountID, iamAccessToken), nil</span>
}

// forIMSToken ...
func forIMSToken(iamAccountID string, imsToken *iam.IMSToken) provider.ContextCredentials <span class="cov0" title="0">{
        return provider.ContextCredentials{
                AuthType:     IMSToken,
                IAMAccountID: iamAccountID,
                UserID:       strconv.Itoa(imsToken.UserID),
                Credential:   imsToken.Token,
        }
}</span>

// forIAMAccessToken ...
func forIAMAccessToken(iamAccountID string, iamAccessToken *iam.AccessToken) provider.ContextCredentials <span class="cov0" title="0">{
        return provider.ContextCredentials{
                AuthType:     IAMAccessToken,
                IAMAccountID: iamAccountID,
                Credential:   iamAccessToken.Token,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package iam ...
package iam

import (
        "encoding/base64"
        "errors"
        "fmt"
        "net/http"
        "strings"
        "time"

        "go.uber.org/zap"

        "github.com/IBM-Cloud/ibm-cloud-cli-sdk/common/rest"
        "github.com/IBM/ibmcloud-volume-interface/config"
        util "github.com/IBM/ibmcloud-volume-interface/lib/utils"
)

// tokenExchangeService ...
type tokenExchangeService struct {
        authConfig *AuthConfiguration
        httpClient *http.Client
}

// AuthConfiguration ...
type AuthConfiguration struct {
        IamURL          string
        IamClientID     string
        IamClientSecret string
}

// TokenExchangeService ...
var _ TokenExchangeService = &amp;tokenExchangeService{}

// NewTokenExchangeServiceWithClient ...
func NewTokenExchangeServiceWithClient(authConfig *AuthConfiguration, httpClient *http.Client) (TokenExchangeService, error) <span class="cov1" title="1">{
        return &amp;tokenExchangeService{
                authConfig: authConfig,
                httpClient: httpClient,
        }, nil
}</span>

// NewTokenExchangeService ...
func NewTokenExchangeService(authConfig *AuthConfiguration) (TokenExchangeService, error) <span class="cov10" title="16">{
        httpClient, err := config.GeneralCAHttpClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="16">return &amp;tokenExchangeService{
                authConfig: authConfig,
                httpClient: httpClient,
        }, nil</span>
}

// tokenExchangeRequest ...
type tokenExchangeRequest struct {
        tes          *tokenExchangeService
        request      *rest.Request
        client       *rest.Client
        logger       *zap.Logger
        errorRetrier *util.ErrorRetrier
}

// tokenExchangeResponse ...
type tokenExchangeResponse struct {
        AccessToken string `json:"access_token"`
        ImsToken    string `json:"ims_token"`
        ImsUserID   int    `json:"ims_user_id"`
}

// ExchangeRefreshTokenForAccessToken ...
func (tes *tokenExchangeService) ExchangeRefreshTokenForAccessToken(refreshToken string, logger *zap.Logger) (*AccessToken, error) <span class="cov6" title="5">{
        r := tes.newTokenExchangeRequest(logger)

        r.request.Field("grant_type", "refresh_token")
        r.request.Field("refresh_token", refreshToken)

        return r.exchangeForAccessToken()
}</span>

// ExchangeAccessTokenForIMSToken ...
func (tes *tokenExchangeService) ExchangeAccessTokenForIMSToken(accessToken AccessToken, logger *zap.Logger) (*IMSToken, error) <span class="cov6" title="5">{
        r := tes.newTokenExchangeRequest(logger)

        r.request.Field("grant_type", "urn:ibm:params:oauth:grant-type:derive")
        r.request.Field("response_type", "ims_portal")
        r.request.Field("access_token", accessToken.Token)

        return r.exchangeForIMSToken()
}</span>

// ExchangeIAMAPIKeyForIMSToken ...
func (tes *tokenExchangeService) ExchangeIAMAPIKeyForIMSToken(iamAPIKey string, logger *zap.Logger) (*IMSToken, error) <span class="cov1" title="1">{
        r := tes.newTokenExchangeRequest(logger)

        r.request.Field("grant_type", "urn:ibm:params:oauth:grant-type:apikey")
        r.request.Field("response_type", "ims_portal")
        r.request.Field("apikey", iamAPIKey)

        return r.exchangeForIMSToken()
}</span>

// ExchangeIAMAPIKeyForAccessToken ...
func (tes *tokenExchangeService) ExchangeIAMAPIKeyForAccessToken(iamAPIKey string, logger *zap.Logger) (*AccessToken, error) <span class="cov5" title="4">{
        r := tes.newTokenExchangeRequest(logger)

        r.request.Field("grant_type", "urn:ibm:params:oauth:grant-type:apikey")
        r.request.Field("apikey", iamAPIKey)

        return r.exchangeForAccessToken()
}</span>

// exchangeForAccessToken ...
func (r *tokenExchangeRequest) exchangeForAccessToken() (*AccessToken, error) <span class="cov8" title="9">{
        var iamResp *tokenExchangeResponse
        var err error
        err = r.errorRetrier.ErrorRetry(func() (error, bool) </span><span class="cov8" title="9">{
                iamResp, err = r.sendTokenExchangeRequest()
                return err, !IsConnectionError(err) // Skip rettry if its not connection error
        }</span>)
        <span class="cov8" title="9">if err != nil </span><span class="cov7" title="7">{
                return nil, err
        }</span>
        <span class="cov3" title="2">return &amp;AccessToken{Token: iamResp.AccessToken}, nil</span>
}

// exchangeForIMSToken ...
func (r *tokenExchangeRequest) exchangeForIMSToken() (*IMSToken, error) <span class="cov6" title="6">{
        var iamResp *tokenExchangeResponse
        var err error
        err = r.errorRetrier.ErrorRetry(func() (error, bool) </span><span class="cov6" title="6">{
                iamResp, err = r.sendTokenExchangeRequest()
                return err, !IsConnectionError(err)
        }</span>)

        <span class="cov6" title="6">if err != nil </span><span class="cov6" title="5">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return &amp;IMSToken{
                UserID: iamResp.ImsUserID,
                Token:  iamResp.ImsToken,
        }, nil</span>
}

// newTokenExchangeRequest ...
func (tes *tokenExchangeService) newTokenExchangeRequest(logger *zap.Logger) *tokenExchangeRequest <span class="cov9" title="15">{
        client := rest.NewClient()
        client.HTTPClient = tes.httpClient
        retyrInterval, _ := time.ParseDuration("3s")
        return &amp;tokenExchangeRequest{
                tes:          tes,
                request:      rest.PostRequest(fmt.Sprintf("%s/oidc/token", tes.authConfig.IamURL)),
                client:       client,
                logger:       logger,
                errorRetrier: util.NewErrorRetrier(40, retyrInterval, logger),
        }
}</span>

// sendTokenExchangeRequest ...
func (r *tokenExchangeRequest) sendTokenExchangeRequest() (*tokenExchangeResponse, error) <span class="cov9" title="15">{
        // Set headers
        basicAuth := fmt.Sprintf("%s:%s", r.tes.authConfig.IamClientID, r.tes.authConfig.IamClientSecret)
        r.request.Set("Authorization", fmt.Sprintf("Basic %s", base64.StdEncoding.EncodeToString([]byte(basicAuth))))
        r.request.Set("Accept", "application/json")

        // Make the request
        var successV tokenExchangeResponse
        var errorV = struct {
                ErrorMessage string `json:"errorMessage"`
                ErrorType    string `json:"errorCode"`
                ErrorDetails string `json:"errorDetails"`
                Requirements struct {
                        Error string `json:"error"`
                        Code  string `json:"code"`
                } `json:"requirements"`
        }{}

        r.logger.Info("Sending IAM token exchange request")
        r.logger.Info("Request is:=================", zap.Reflect("Request", r.request))
        resp, err := r.client.Do(r.request, &amp;successV, &amp;errorV)

        if err != nil </span><span class="cov6" title="5">{
                r.logger.Error("IAM token exchange request failed", zap.Reflect("Response", resp), zap.Error(err))

                // TODO Handle timeout here?

                return nil,
                        util.NewError("ErrorUnclassified",
                                "IAM token exchange request failed", err)
        }</span>

        <span class="cov8" title="10">if resp != nil &amp;&amp; resp.StatusCode == 200 </span><span class="cov4" title="3">{
                r.logger.Debug("IAM token exchange request successful")
                return &amp;successV, nil
        }</span>

        <span class="cov7" title="7">defer resp.Body.Close()

        // TODO Check other status code values? (but be careful not to mask the reason codes, below)

        if errorV.ErrorMessage != "" </span><span class="cov5" title="4">{
                r.logger.Error("IAM token exchange request failed with message",
                        zap.Int("StatusCode", resp.StatusCode),
                        zap.String("ErrorMessage:", errorV.ErrorMessage),
                        zap.String("ErrorType:", errorV.ErrorType),
                        zap.Reflect("Error", errorV))

                err := util.NewError("ErrorFailedTokenExchange",
                        "IAM token exchange request failed: "+errorV.ErrorMessage,
                        errors.New(errorV.ErrorDetails+" "+errorV.Requirements.Code+": "+errorV.Requirements.Error))

                if errorV.Requirements.Code == "SoftLayer_Exception_User_Customer_AccountLocked" </span><span class="cov1" title="1">{
                        err = util.NewError("ErrorProviderAccountTemporarilyLocked",
                                "Infrastructure account is temporarily locked", err)
                }</span>

                <span class="cov5" title="4">return nil, err</span>
        }

        <span class="cov4" title="3">r.logger.Error("Unexpected IAM token exchange response",
                zap.Int("StatusCode", resp.StatusCode), zap.Reflect("Response", resp))

        return nil,
                util.NewError("ErrorUnclassified",
                        "Unexpected IAM token exchange response")</span>
}

// IsConnectionError ...
func IsConnectionError(err error) bool <span class="cov9" title="15">{
        if err != nil </span><span class="cov9" title="12">{
                wrappedErrors := util.ErrorDeepUnwrapString(err)
                // wrapped error contains actual backend error
                for _, werr := range wrappedErrors </span><span class="cov8" title="10">{
                        if strings.Contains(werr, "tcp") </span><span class="cov0" title="0">{
                                // if  error contains "tcp" string, its connection error
                                return true
                        }</span>
                }
        }
        <span class="cov9" title="15">return false</span>
}

// String returns a pointer to the string value provided
func String(v string) *string <span class="cov4" title="3">{
        return &amp;v
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/**
 * Copyright 2020 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package iam ...
package iam

import (
        "errors"

        "github.com/dgrijalva/jwt-go"

        "go.uber.org/zap"
)

type accessTokenClaims struct {
        jwt.StandardClaims

        Account struct {
                Bss string `json:"bss"`
        } `json:"account"`
}

func (r *tokenExchangeService) GetIAMAccountIDFromAccessToken(accessToken AccessToken, logger *zap.Logger) (accountID string, err error) <span class="cov8" title="1">{
        // TODO - TEMPORARY CODE - VERIFY SIGNATURE HERE
        token, _, err := new(jwt.Parser).ParseUnverified(accessToken.Token, &amp;accessTokenClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">token.Valid = true
        // TODO - TEMPORARY CODE - DONT OVERRIDE VERIFICATION

        claims, haveClaims := token.Claims.(*accessTokenClaims)

        logger.Debug("Access token parsed", zap.Bool("haveClaims", haveClaims), zap.Bool("valid", token.Valid))

        if !token.Valid || !haveClaims </span><span class="cov0" title="0">{
                err = errors.New("access token invalid")
                return
        }</span>

        <span class="cov8" title="1">accountID = claims.Account.Bss
        logger.Debug("GetIAMAccountIDFromAccessToken", zap.Reflect("claims.Account.Bss", claims.Account.Bss))

        return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
