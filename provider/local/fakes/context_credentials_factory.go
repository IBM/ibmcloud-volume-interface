// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.com/IBM/ibmcloud-volume-interface/lib/provider"
	"github.com/IBM/ibmcloud-volume-interface/provider/local"
	"go.uber.org/zap"
)

type ContextCredentialsFactory struct {
	ForIAMAPIKeyStub        func(string, string, *zap.Logger) (provider.ContextCredentials, error)
	forIAMAPIKeyMutex       sync.RWMutex
	forIAMAPIKeyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}
	forIAMAPIKeyReturns struct {
		result1 provider.ContextCredentials
		result2 error
	}
	forIAMAPIKeyReturnsOnCall map[int]struct {
		result1 provider.ContextCredentials
		result2 error
	}
	ForIAMAccessTokenStub        func(string, *zap.Logger) (provider.ContextCredentials, error)
	forIAMAccessTokenMutex       sync.RWMutex
	forIAMAccessTokenArgsForCall []struct {
		arg1 string
		arg2 *zap.Logger
	}
	forIAMAccessTokenReturns struct {
		result1 provider.ContextCredentials
		result2 error
	}
	forIAMAccessTokenReturnsOnCall map[int]struct {
		result1 provider.ContextCredentials
		result2 error
	}
	ForIaaSAPIKeyStub        func(string, string, string, *zap.Logger) (provider.ContextCredentials, error)
	forIaaSAPIKeyMutex       sync.RWMutex
	forIaaSAPIKeyArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *zap.Logger
	}
	forIaaSAPIKeyReturns struct {
		result1 provider.ContextCredentials
		result2 error
	}
	forIaaSAPIKeyReturnsOnCall map[int]struct {
		result1 provider.ContextCredentials
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ContextCredentialsFactory) ForIAMAPIKey(arg1 string, arg2 string, arg3 *zap.Logger) (provider.ContextCredentials, error) {
	fake.forIAMAPIKeyMutex.Lock()
	ret, specificReturn := fake.forIAMAPIKeyReturnsOnCall[len(fake.forIAMAPIKeyArgsForCall)]
	fake.forIAMAPIKeyArgsForCall = append(fake.forIAMAPIKeyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *zap.Logger
	}{arg1, arg2, arg3})
	stub := fake.ForIAMAPIKeyStub
	fakeReturns := fake.forIAMAPIKeyReturns
	fake.recordInvocation("ForIAMAPIKey", []interface{}{arg1, arg2, arg3})
	fake.forIAMAPIKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ContextCredentialsFactory) ForIAMAPIKeyCallCount() int {
	fake.forIAMAPIKeyMutex.RLock()
	defer fake.forIAMAPIKeyMutex.RUnlock()
	return len(fake.forIAMAPIKeyArgsForCall)
}

func (fake *ContextCredentialsFactory) ForIAMAPIKeyCalls(stub func(string, string, *zap.Logger) (provider.ContextCredentials, error)) {
	fake.forIAMAPIKeyMutex.Lock()
	defer fake.forIAMAPIKeyMutex.Unlock()
	fake.ForIAMAPIKeyStub = stub
}

func (fake *ContextCredentialsFactory) ForIAMAPIKeyArgsForCall(i int) (string, string, *zap.Logger) {
	fake.forIAMAPIKeyMutex.RLock()
	defer fake.forIAMAPIKeyMutex.RUnlock()
	argsForCall := fake.forIAMAPIKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ContextCredentialsFactory) ForIAMAPIKeyReturns(result1 provider.ContextCredentials, result2 error) {
	fake.forIAMAPIKeyMutex.Lock()
	defer fake.forIAMAPIKeyMutex.Unlock()
	fake.ForIAMAPIKeyStub = nil
	fake.forIAMAPIKeyReturns = struct {
		result1 provider.ContextCredentials
		result2 error
	}{result1, result2}
}

func (fake *ContextCredentialsFactory) ForIAMAPIKeyReturnsOnCall(i int, result1 provider.ContextCredentials, result2 error) {
	fake.forIAMAPIKeyMutex.Lock()
	defer fake.forIAMAPIKeyMutex.Unlock()
	fake.ForIAMAPIKeyStub = nil
	if fake.forIAMAPIKeyReturnsOnCall == nil {
		fake.forIAMAPIKeyReturnsOnCall = make(map[int]struct {
			result1 provider.ContextCredentials
			result2 error
		})
	}
	fake.forIAMAPIKeyReturnsOnCall[i] = struct {
		result1 provider.ContextCredentials
		result2 error
	}{result1, result2}
}

func (fake *ContextCredentialsFactory) ForIAMAccessToken(arg1 string, arg2 *zap.Logger) (provider.ContextCredentials, error) {
	fake.forIAMAccessTokenMutex.Lock()
	ret, specificReturn := fake.forIAMAccessTokenReturnsOnCall[len(fake.forIAMAccessTokenArgsForCall)]
	fake.forIAMAccessTokenArgsForCall = append(fake.forIAMAccessTokenArgsForCall, struct {
		arg1 string
		arg2 *zap.Logger
	}{arg1, arg2})
	stub := fake.ForIAMAccessTokenStub
	fakeReturns := fake.forIAMAccessTokenReturns
	fake.recordInvocation("ForIAMAccessToken", []interface{}{arg1, arg2})
	fake.forIAMAccessTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ContextCredentialsFactory) ForIAMAccessTokenCallCount() int {
	fake.forIAMAccessTokenMutex.RLock()
	defer fake.forIAMAccessTokenMutex.RUnlock()
	return len(fake.forIAMAccessTokenArgsForCall)
}

func (fake *ContextCredentialsFactory) ForIAMAccessTokenCalls(stub func(string, *zap.Logger) (provider.ContextCredentials, error)) {
	fake.forIAMAccessTokenMutex.Lock()
	defer fake.forIAMAccessTokenMutex.Unlock()
	fake.ForIAMAccessTokenStub = stub
}

func (fake *ContextCredentialsFactory) ForIAMAccessTokenArgsForCall(i int) (string, *zap.Logger) {
	fake.forIAMAccessTokenMutex.RLock()
	defer fake.forIAMAccessTokenMutex.RUnlock()
	argsForCall := fake.forIAMAccessTokenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ContextCredentialsFactory) ForIAMAccessTokenReturns(result1 provider.ContextCredentials, result2 error) {
	fake.forIAMAccessTokenMutex.Lock()
	defer fake.forIAMAccessTokenMutex.Unlock()
	fake.ForIAMAccessTokenStub = nil
	fake.forIAMAccessTokenReturns = struct {
		result1 provider.ContextCredentials
		result2 error
	}{result1, result2}
}

func (fake *ContextCredentialsFactory) ForIAMAccessTokenReturnsOnCall(i int, result1 provider.ContextCredentials, result2 error) {
	fake.forIAMAccessTokenMutex.Lock()
	defer fake.forIAMAccessTokenMutex.Unlock()
	fake.ForIAMAccessTokenStub = nil
	if fake.forIAMAccessTokenReturnsOnCall == nil {
		fake.forIAMAccessTokenReturnsOnCall = make(map[int]struct {
			result1 provider.ContextCredentials
			result2 error
		})
	}
	fake.forIAMAccessTokenReturnsOnCall[i] = struct {
		result1 provider.ContextCredentials
		result2 error
	}{result1, result2}
}

func (fake *ContextCredentialsFactory) ForIaaSAPIKey(arg1 string, arg2 string, arg3 string, arg4 *zap.Logger) (provider.ContextCredentials, error) {
	fake.forIaaSAPIKeyMutex.Lock()
	ret, specificReturn := fake.forIaaSAPIKeyReturnsOnCall[len(fake.forIaaSAPIKeyArgsForCall)]
	fake.forIaaSAPIKeyArgsForCall = append(fake.forIaaSAPIKeyArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 *zap.Logger
	}{arg1, arg2, arg3, arg4})
	stub := fake.ForIaaSAPIKeyStub
	fakeReturns := fake.forIaaSAPIKeyReturns
	fake.recordInvocation("ForIaaSAPIKey", []interface{}{arg1, arg2, arg3, arg4})
	fake.forIaaSAPIKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ContextCredentialsFactory) ForIaaSAPIKeyCallCount() int {
	fake.forIaaSAPIKeyMutex.RLock()
	defer fake.forIaaSAPIKeyMutex.RUnlock()
	return len(fake.forIaaSAPIKeyArgsForCall)
}

func (fake *ContextCredentialsFactory) ForIaaSAPIKeyCalls(stub func(string, string, string, *zap.Logger) (provider.ContextCredentials, error)) {
	fake.forIaaSAPIKeyMutex.Lock()
	defer fake.forIaaSAPIKeyMutex.Unlock()
	fake.ForIaaSAPIKeyStub = stub
}

func (fake *ContextCredentialsFactory) ForIaaSAPIKeyArgsForCall(i int) (string, string, string, *zap.Logger) {
	fake.forIaaSAPIKeyMutex.RLock()
	defer fake.forIaaSAPIKeyMutex.RUnlock()
	argsForCall := fake.forIaaSAPIKeyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *ContextCredentialsFactory) ForIaaSAPIKeyReturns(result1 provider.ContextCredentials, result2 error) {
	fake.forIaaSAPIKeyMutex.Lock()
	defer fake.forIaaSAPIKeyMutex.Unlock()
	fake.ForIaaSAPIKeyStub = nil
	fake.forIaaSAPIKeyReturns = struct {
		result1 provider.ContextCredentials
		result2 error
	}{result1, result2}
}

func (fake *ContextCredentialsFactory) ForIaaSAPIKeyReturnsOnCall(i int, result1 provider.ContextCredentials, result2 error) {
	fake.forIaaSAPIKeyMutex.Lock()
	defer fake.forIaaSAPIKeyMutex.Unlock()
	fake.ForIaaSAPIKeyStub = nil
	if fake.forIaaSAPIKeyReturnsOnCall == nil {
		fake.forIaaSAPIKeyReturnsOnCall = make(map[int]struct {
			result1 provider.ContextCredentials
			result2 error
		})
	}
	fake.forIaaSAPIKeyReturnsOnCall[i] = struct {
		result1 provider.ContextCredentials
		result2 error
	}{result1, result2}
}

func (fake *ContextCredentialsFactory) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.forIAMAPIKeyMutex.RLock()
	defer fake.forIAMAPIKeyMutex.RUnlock()
	fake.forIAMAccessTokenMutex.RLock()
	defer fake.forIAMAccessTokenMutex.RUnlock()
	fake.forIaaSAPIKeyMutex.RLock()
	defer fake.forIaaSAPIKeyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ContextCredentialsFactory) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ local.ContextCredentialsFactory = new(ContextCredentialsFactory)
